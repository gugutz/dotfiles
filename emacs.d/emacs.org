# -*- mode: org -*-
//#+OPTIONS: toc:0 num:nil
# #######################################################################
#+TITLE:     emacs configuration file
#+SUBTITLE:  ORGfied configuration for Emacs
#+AUTHOR:    Gustavo P Borges
#+EMAIL:     gustavo.pb1984@aluno.ifsc.edu.br
#+DESCRIPTION: This file is compiled to init.el automatically on every save
# #######################################################################

* Recompile init.el everytime emacs.org is changed and saved
  
   Moved this to beggining of the file to avoid it not being parsed when theres an error in the middle of the file
It was being recompiled without this function so i had to manually re-copy first-init.el to make it compile first time again and again


#+BEGIN_SRC emacs-lisp :tangle init.el
(defun /util/tangle-init ()
  (interactive)
  "If the current buffer is init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "emacs.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file (concat user-emacs-directory "init.el")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-save-hook #'/util/tangle-init)
#+END_SRC

* Package Repositories

#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'package)
  ;; add melpa stable emacs package repository
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t) ; Org-mode's repository
#+END_SRC

** initialize packages
#+BEGIN_SRC emacs-lisp :tangle init.el
  (package-initialize)
#+END_SRC

moved this part to beggining of the file because if the
custom-safe-themes variable is not set before smart-mode-line (sml) activates
emacs asks 2 annoying confirmations on every startup before actually starting

#+BEGIN_SRC emacs-lisp :tangle init.el
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(custom-safe-themes
   (quote
    ("84d2f9eeb3f82d619ca4bfffe5f157282f4779732f48a5ac1484d94d5ff5b279" "57f95012730e3a03ebddb7f2925861ade87f53d5bbb255398357731a7b1ac0e0" "3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default)))
 '(fci-rule-color "#3E4451")
 '(package-selected-packages
   (quote
   (pdf-tools ox-pandoc ox-reveal org-preview-html latex-preview-pane smart-mode-line-powerline-theme base16-theme gruvbox-theme darktooth-theme rainbow-mode smartscan restclient editorconfig prettier-js pandoc rjsx-mode js2-refactor web-mode evil-org multiple-cursors flycheck smart-mode-line ## evil-leader evil-commentary evil-surround htmlize magit neotree evil json-mode web-serverx org))))
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
#+END_SRC

* Bindings


These macros are to help me remap keys.

#+BEGIN_SRC emacs-lisp :tangle init.el
(defmacro /bindings/define-prefix-keys (keymap prefix &rest body)
  (declare (indent defun))
  `(progn
     ,@(cl-loop for binding in body
                collect
                `(let ((seq ,(car binding))
                       (func ,(cadr binding))
                       (desc ,(caddr binding)))
                   (define-key ,keymap (kbd seq) func)
                   (when desc
                     (which-key-add-key-based-replacements
                       (if ,prefix
                           (concat ,prefix " " seq)
                         seq)
                       desc))))))

(defmacro /bindings/define-keys (keymap &rest body)
  (declare (indent defun))
  `(/bindings/define-prefix-keys ,keymap nil ,@body))

(defmacro /bindings/define-key (keymap sequence binding &optional description)
  (declare (indent defun))
  `(/bindings/define-prefix-keys ,keymap nil
     (,sequence ,binding ,description)))
#+END_SRC

* Environment setup

** Allow access from emacsclient
   
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'server)
  (unless (or (daemonp) (server-running-p))
    (server-start))
#+END_SRC


** Prevent emacs to create lockfiles (.#files#). 
   
PS: this also stops preventing editing colisions, so watch out

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq create-lockfiles nil)
#+END_SRC


** Always follow symbolic links to edit the 'actual' file it points to
   
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq vc-follow-symlinks t)
#+END_SRC


** Enable mouse support in terminal mode
   
#+BEGIN_SRC emacs-lisp :tangle init.el
(when (eq window-system nil)
  (xterm-mouse-mode 1))
#+END_SRC


** Save all tempfiles in $TMPDIR/emacs$UID/
   
#+BEGIN_SRC emacs-lisp :tangle init.el
    (defconst emacs-tmp-dir (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))
    (setq backup-directory-alist
        `((".*" . ,emacs-tmp-dir)))
    (setq auto-save-file-name-transforms
        `((".*" ,emacs-tmp-dir t)))
    (setq auto-save-list-file-prefix
        emacs-tmp-dir)
#+END_SRC
        
      
** Disable the annoying Emacs bell ring (beep)

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq ring-bell-function 'ignore)
#+END_SRC


* After 

with-eval-after-load is a function that lets you defer execution of code until after a feature has been loaded.
It is very useful to only load some packages when they’re, and because of that it is extensively used in this setup. 
So of course there is a macro to make it simpler. It can also run code if a package has been installed by using “pkgname-autoloads” or only if multiple packages have been loaded.
This also avoids loading config for packages that haven’t been loaded yet, resulting in void variables of function definitions. 
This was take from milkypostman (along with some other things).

#+BEGIN_SRC emacs-lisp :tangle init.el
;; examples
;; after [evil magit] (
  ;; execute after evil and magit have been loaded
;  )

;; macro definiton
(defmacro after (feature &rest body)
  "Executes BODY after FEATURE has been loaded.

FEATURE may be any one of:
    'evil            => (with-eval-after-load 'evil BODY)
    \"evil-autoloads\" => (with-eval-after-load \"evil-autolaods\" BODY)
    [evil cider]     => (with-eval-after-load 'evil
                          (with-eval-after-load 'cider
                            BODY))
"
  (declare (indent 1))
  (cond
   ((vectorp feature)
    (let ((prog (macroexp-progn body)))
      (cl-loop for f across feature
               do
               (progn
                 (setq prog (append `(',f) `(,prog)))
                 (setq prog (append '(with-eval-after-load) prog))))
      prog))
   (t
    `(with-eval-after-load ,feature ,@body))))
#+END_SRC

* Packages
   
** Add the folder 'config' to emacs load-path so i can require stuff from there

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-to-list 'load-path (expand-file-name "config" user-emacs-directory))
  ;; (add-to-list 'load-path "~/dotfiles/emacs.d/config")

#+END_SRC



** Require needed packages
#+BEGIN_SRC emacs-lisp :tangle init.el

    (require 'evil.tau)
    (require 'org.tau)

#+END_SRC


* Evil

: All Evil settings are meant to be isolated in a separate file evil.tau.

** Require Evil related packages

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (require 'evil)
  (evil-mode 1)
#+END_SRC



** Don't wait for any other keys after escape is pressed.
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (setq evil-esc-delay 0)
#+END_SRC


** Make Evil look a bit more like (n) vim  (??)
: not sure what all these options do yet

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (setq evil-search-module 'isearch-regexp)
  (setq evil-magic 'very-magic)
  (setq evil-shift-width (symbol-value 'tab-width))
  (setq evil-regexp-search t)
  (setq evil-search-wrap t)
  ;; (setq evil-want-C-i-jump t)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-fine-undo nil)
  (setq evil-want-integration nil)
  ;; (setq evil-want-abbrev-on-insert-exit nil)
  (setq evil-want-abbrev-expand-on-insert-exit nil)
  ;; move evil tag to beginning of modeline
  (setq evil-mode-line-format '(before . mode-line-front-space))
#+END_SRC




** Simulate Vim behaviour and some bindings

   
*** make esc quit or cancel everything in Emacs
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC




** Cursor is alway black because of evil.

: Here is the workaround
: (@see https://bitbucket.org/lyro/evil/issue/342/evil-default-cursor-setting-should-default)
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (setq evil-default-cursor t)
#+END_SRC



*** recover native emacs commands that are overriden by evil
: this gives priority to native emacs behaviour rathen than Vim's

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (define-key evil-normal-state-map (kbd "SPC") 'ace-jump-mode)
  (define-key evil-insert-state-map (kbd "C-e") 'move-end-of-line)
  (define-key evil-insert-state-map (kbd "C-k") 'kill-line)
  (define-key evil-normal-state-map (kbd "C-k") 'kill-line)
  (define-key evil-insert-state-map (kbd "C-w") 'kill-region)
  (define-key evil-normal-state-map (kbd "C-w") 'kill-region)
  (define-key evil-visual-state-map (kbd "C-w") 'kill-region)
  (define-key evil-visual-state-map (kbd "C-e") 'move-end-of-line)
  (define-key evil-normal-state-map (kbd "C-e") 'move-end-of-line)
  (define-key evil-normal-state-map (kbd "C-y") 'yank)
  (define-key evil-insert-state-map (kbd "C-y") 'yank)
  (define-key evil-visual-state-map (kbd "SPC") 'ace-jump-mode)
  (define-key evil-normal-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-insert-state-map "\C-e" 'end-of-line)
  (define-key evil-visual-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-motion-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-normal-state-map "\C-f" 'evil-forward-char)
  (define-key evil-insert-state-map "\C-f" 'evil-forward-char)
  (define-key evil-insert-state-map "\C-f" 'evil-forward-char)
  (define-key evil-normal-state-map "\C-b" 'evil-backward-char)
  (define-key evil-insert-state-map "\C-b" 'evil-backward-char)
  (define-key evil-visual-state-map "\C-b" 'evil-backward-char)
  (define-key evil-normal-state-map "\C-d" 'evil-delete-char)
  (define-key evil-insert-state-map "\C-d" 'evil-delete-char)
  (define-key evil-visual-state-map "\C-d" 'evil-delete-char)
  (define-key evil-normal-state-map "\C-n" 'evil-next-line)
  (define-key evil-insert-state-map "\C-n" 'evil-next-line)
  (define-key evil-visual-state-map "\C-n" 'evil-next-line)
  (define-key evil-normal-state-map "\C-p" 'evil-previous-line)
  (define-key evil-insert-state-map "\C-p" 'evil-previous-line)
  (define-key evil-visual-state-map "\C-p" 'evil-previous-line)
  (define-key evil-normal-state-map "\C-w" 'evil-delete)
  (define-key evil-insert-state-map "\C-w" 'evil-delete)
  (define-key evil-visual-state-map "\C-w" 'evil-delete)
  (define-key evil-normal-state-map "\C-y" 'yank)
  (define-key evil-insert-state-map "\C-y" 'yank)
  (define-key evil-visual-state-map "\C-y" 'yank)
  (define-key evil-normal-state-map "\C-k" 'kill-line)
  (define-key evil-insert-state-map "\C-k" 'kill-line)
  (define-key evil-visual-state-map "\C-k" 'kill-line)
  (define-key evil-normal-state-map "Q" 'call-last-kbd-macro)
  (define-key evil-visual-state-map "Q" 'call-last-kbd-macro)
  (define-key evil-insert-state-map "\C-e" 'end-of-line)
  (define-key evil-insert-state-map "\C-r" 'search-backward)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  ;; (define-key evil-window-map "\C-h" 'evil-window-left)
  ;; (define-key evil-window-map "\C-j" 'evil-window-down)
  ;; (define-key evil-window-map "\C-k" 'evil-window-up)
  ;; (define-key evil-window-map "\C-l" 'evil-window-right)
#+END_SRC



*** change cursor color according to mode
    
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (setq evil-emacs-state-cursor '("#ff0000" box))
  (setq evil-motion-state-cursor '("#FFFFFF" box))
  (setq evil-normal-state-cursor '("#00ff00" box))
  (setq evil-visual-state-cursor '("#abcdef" box))
  (setq evil-insert-state-cursor '("#e2f00f" bar))
  (setq evil-replace-state-cursor '("red" hbar))
  (setq evil-operator-state-cursor '("red" hollow))
#+END_SRC

*** multiple cursors

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  ;; step 1, select thing in visual-mode (OPTIONAL)
  ;; step 2, `mc/mark-all-like-dwim' or `mc/mark-all-like-this-in-defun'
  ;; step 3, `ace-mc-add-multiple-cursors' to remove cursor, press RET to confirm
  ;; step 4, press s or S to start replace
  ;; step 5, press C-g to quit multiple-cursors
  (define-key evil-visual-state-map (kbd "mn") 'mc/mark-next-like-this)
  (define-key evil-visual-state-map (kbd "ma") 'mc/mark-all-like-this-dwim)
  (define-key evil-visual-state-map (kbd "md") 'mc/mark-all-like-this-in-defun)
  (define-key evil-visual-state-map (kbd "mm") 'ace-mc-add-multiple-cursors)
  (define-key evil-visual-state-map (kbd "ms") 'ace-mc-add-single-cursor)
#+END_SRC

*** imitate vim multiple selection behavior with multiple-cursors package
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  ;; (define-key evil-normal-state-map (kbd "C-n") 'mc/mark-next-like-this)
  ;; (define-key evil-normal-state-map (kbd "M-N") 'mc/mark-previous-like-this)
#+END_SRC


*** evil-leader

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(require 'evil-leader)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (global-evil-leader-mode)
  (evil-leader/set-leader ",")
  (evil-leader/set-key
    "e" 'find-file
    "q" 'evil-quit
    "w" 'save-buffer
    "k" 'kill-buffer
    "b" 'switch-to-buffer
    "-" 'split-window-bellow
    "|" 'split-window-right)
#+END_SRC

*** Evil Surround
: @see https://github.com/timcharper/evil-surround for tutorial

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (require 'evil-surround)
  (global-evil-surround-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(defun evil-surround-prog-mode-hook-setup ()
  "Documentation string, idk, put something here later."
  (push '(47 . ("/" . "/")) evil-surround-pairs-alist)
  (push '(40 . ("(" . ")")) evil-surround-pairs-alist)
  (push '(41 . ("(" . ")")) evil-surround-pairs-alist)
  (push '(91 . ("[" . "]")) evil-surround-pairs-alist)
  (push '(93 . ("[" . "]")) evil-surround-pairs-alist))
(add-hook 'prog-mode-hook 'evil-surround-prog-mode-hook-setup)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(defun evil-surround-js-mode-hook-setup ()
  "ES6." ;  <-- this is a documentation string, a feature in Lisp
  ;; I believe this is for auto closing pairs
  (push '(?1 . ("{`" . "`}")) evil-surround-pairs-alist)
  (push '(?2 . ("${" . "}")) evil-surround-pairs-alist)
  (push '(?4 . ("(e) => " . "(e)")) evil-surround-pairs-alist)
  ;; ReactJS
  (push '(?3 . ("classNames(" . ")")) evil-surround-pairs-alist))
(add-hook 'js2-mode-hook 'evil-surround-js-mode-hook-setup)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(defun evil-surround-emacs-lisp-mode-hook-setup ()
  (push '(?` . ("`" . "'")) evil-surround-pairs-alist))
(add-hook 'emacs-lisp-mode-hook 'evil-surround-emacs-lisp-mode-hook-setup)
(defun evil-surround-org-mode-hook-setup ()
  (push '(91 . ("[" . "]")) evil-surround-pairs-alist)
  (push '(93 . ("[" . "]")) evil-surround-pairs-alist)
  (push '(?= . ("=" . "=")) evil-surround-pairs-alist))
(add-hook 'org-mode-hook 'evil-surround-org-mode-hook-setup)
#+END_SRC





** Vim plugins definitions


*** Vim Commentary
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(require 'evil-commentary)
(evil-commentary-mode)
#+END_SRC

*** Evil-Matchit
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(require 'evil-matchit)
(global-evil-matchit-mode 1)
#+END_SRC



* ORG mode

  The ORG part of the config compiles to a separate file, inside the config folder, called `org.el`
 
** Require ORG
   
#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(require 'org)
#+END_SRC

** Resolve issue with Tab not working with ORG only in Normal VI Mode in terminal
   
(something with TAB on terminals being related to C-i...)

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
  (add-hook 'org-mode-hook                                                                      
            (lambda ()                                                                          
          (define-key evil-normal-state-map (kbd "TAB") 'org-cycle))) 

  ;; (setq evil-want-C-i-jump nil)
#+END_SRC
 



** Show CLOSED tag line in closed TODO items
   
#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(setq org-log-done 'time)
#+END_SRC

** Prompt to leave a note when closing an item
#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(setq org-log-done 'note)
#+END_SRC

#+BEGIN_NOTE 
Also achievable on a per file basis with: #+STARTUP: logdone
#+STARTUP: logdone
#+STARTUP: lognotedone.
#+END_NOTE

** Function to activate export-on-save in org mode

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(defun toggle-org-html-export-on-save ()
  "Make Emacs auto-export to HTML when org file is saved.
Enable calling this function from the file with <M-x>."
  (interactive)
  (if (memq 'org-html-export-to-html after-save-hook)
      (progn
        (remove-hook 'after-save-hook 'org-html-export-to-html t)
        (message "Disabled org html export on save for current buffer..."))
    (add-hook 'after-save-hook 'org-html-export-to-html nil t)
    (message "Enabled org html export on save for current buffer...")))
#+END_SRC


** Add hook to auto-export automatically on saveing ORG files

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
  (defun org-mode-export-hook ()
    "This exports to diffenent outputs everytime the file is saved.
  This will be added to org-mode-hook, so it only activates on ORG files.
  Generates outputs in these formats:
  - PDF
  - HTML
  - RevealJS."
     (add-hook 'after-save-hook 'org-beamer-export-to-pdf t t)
     (add-hook 'after-save-hook 'org-reveal-export-to-html t t))

  ; Finally adds the above hook in org-mode-hook.
  ;; (add-hook 'org-mode-hook #'org-mode-export-hook)
#+END_SRC


** Evil-ORG


 #+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
 (after 'org
   (require 'evil-org)
   (require 'evil-org-agenda)
   (add-hook 'org-mode-hook #'evil-org-mode)
   (add-hook 'evil-org-mode-hook
             (lambda ()
               (evil-org-set-key-theme))))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
 ;; (add-hook 'org-mode-hook 'evil-org-mode)
 ;; (evil-org-set-key-theme '(navigation insert textobjects additional calendar))
 ;; (evil-org-agenda-set-keys)
 #+END_SRC


 
*** Simulate <leader> key with Spacebar

 #+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
     (defvar my-leader-map (make-sparse-keymap)
       "Keymap for \"leader key\" shortcuts.")

     ;; binding "SPC" to the keymap
    (define-key evil-normal-state-map (kbd "M-SPC") my-leader-map)

     ;; binding using SPC leader
     (define-key my-leader-map "b" 'list-buffers)
     (define-key my-leader-map "w" 'evil-save)
     (define-key my-leader-map "SPC" ":noh")
 #+END_SRC

 # #+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
 #   (/bindings/define-keys evil-normal-state-map
 #     ("C-w h" #'evil-window-left)
 #     ("C-w j" #'evil-window-down)
 #     ("C-w k" #'evil-window-up)
 #     ("C-w l" #'evil-window-right))
 # #+END_SRC

 
 
** ox-pandoc

As pandoc supports many number of formats, initial org-export-dispatch
shortcut menu does not show full of its supported formats. You can customize
org-pandoc-menu-entry variable (and probably restart Emacs) to change its
default menu entries.
If you want delayed loading of `ox-pandoc’ when org-pandoc-menu-entry
is customized, please consider the following settings in your init file"

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(with-eval-after-load 'ox
  (require 'ox-pandoc))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(require 'ox-pandoc)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
  ;; default options for all output formats
  (setq org-pandoc-options '((standalone . t)))
  ;; cancel above settings only for 'docx' format
  (setq org-pandoc-options-for-docx '((standalone . nil)))
  ;; special settings for beamer-pdf and latex-pdf exporters
  (setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
  (setq org-pandoc-options-for-latex-pdf '((pdf-engine . "luatex")))
  ;; special extensions for markdown_github output
  (setq org-pandoc-format-extensions '(markdown_github+pipe_tables+raw_html))
#+END_SRC


** ox-twbs (exporter to twitter bootstrap html)
#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
   (setq org-enable-bootstrap-support t)
#+END_SRC
   

** ReveaJS org-reveal:
: This delay makes the options to export to RevealJS appear on the exporter menu (C-c C-e)

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(with-eval-after-load 'ox
  (require 'ox-reveal))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
(require 'ox-reveal)
#+END_SRC



** UTF8 pretty bullets in org mode
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))


* Neotree

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(require 'neotree)
#+END_SRC

** neotree 'icons' theme, which supports filetype icons
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
    ;; (after 'neotree
  ;; (setq neo-theme (if (display-graphic-p) 'icons))

    (setq neo-theme 'icons)
#+END_SRC


** set NeoTree default window width
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(setq neo-window-width 32)
#+END_SRC

** toggle neotree with F8
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(global-set-key [f8] 'neotree-toggle)
#+END_SRC


** make nerdtree open on emacs startup
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(add-hook 'after-init-hook #'neotree-toggle)
#+END_SRC




** make neotree window open and go the file currently opened
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(setq neo-smart-open t)
#+END_SRC


** solve keybinding conflicts between neotree with evil mode
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (add-hook 'neotree-mode-hook
            (lambda ()
              ; default Neotree bindings
              (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-enter)
              (define-key evil-normal-state-local-map (kbd "SPC") 'neotree-quick-look)
              (define-key evil-normal-state-local-map (kbd "q") 'neotree-hide)
              (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)
              (define-key evil-normal-state-local-map (kbd "g") 'neotree-refresh)
              (define-key evil-normal-state-local-map (kbd "n") 'neotree-next-line)
              (define-key evil-normal-state-local-map (kbd "p") 'neotree-previous-line)
              (define-key evil-normal-state-local-map (kbd "A") 'neotree-stretch-toggle)
              (define-key evil-normal-state-local-map (kbd "H") 'neotree-hidden-file-toggle)
              (define-key evil-normal-state-local-map (kbd "|") 'neotree-enter-vertical-split)
              (define-key evil-normal-state-local-map (kbd "-") 'neotree-enter-horizontal-split)
              ; simulating NERDTree bindings in Neotree
              (define-key evil-normal-state-local-map (kbd "R") 'neotree-refresh)
              (define-key evil-normal-state-local-map (kbd "r") 'neotree-refresh)
              (define-key evil-normal-state-local-map (kbd "u") 'neotree-refresh)
              (define-key evil-normal-state-local-map (kbd "C") 'neotree-change-root)
              (define-key evil-normal-state-local-map (kbd "c") 'neotree-create-node)))
#+END_SRC

* Shell
  
** System Shell
*** Make system shell open in a split-window buffer at the bottom of the screen
   
 #+BEGIN_SRC emacs-lisp :tangle init.el
   (defun /shell/new-window ()
       "Opens up a new shell in the directory associated with the current buffer's file." 
       (interactive)
       (let* ((parent (if (buffer-file-name)
			  (file-name-directory (buffer-file-name))
			default-directory))
	      (height (/ (window-total-height) 3))
	      (name   (car (last (split-string parent "/" t)))))
	 (split-window-vertically (- height))
	 (other-window 1)
	 (shell "new")
	 (rename-buffer (concat "*shell: " name "*"))

	 (insert (concat "ls"))
	 ))

   ; Pull system shell in a new bottom window
   ;; (define-key evil-normal-state-map (kbd "\"") #'/shell/new-window)
   ;; (define-key evil-visual-state-map (kbd "\"") #'/shell/new-window)
   ;; (define-key evil-motion-state-map (kbd "\"") #'/shell/new-window)
 #+END_SRC

  
** Eshell

*** Make eshell open in a split-window buffer at the bottom of the screen
   
 #+BEGIN_SRC emacs-lisp :tangle init.el
 (defun /eshell/new-window ()
     "Opens up a new eshell in the directory associated with the current buffer's file.  The eshell is renamed to match that directory to make multiple eshell windows easier."
     (interactive)
     (let* ((parent (if (buffer-file-name)
                        (file-name-directory (buffer-file-name))
                      default-directory))
            (height (/ (window-total-height) 3))
            (name   (car (last (split-string parent "/" t)))))
       (split-window-vertically (- height))
       (other-window 1)
       (eshell "new")
       (rename-buffer (concat "*eshell: " name "*"))

       (insert (concat "ls"))
       (eshell-send-input)))

 ; Pull eshell in a new bottom window
 (define-key evil-normal-state-map (kbd "!") #'/eshell/new-window)
 (define-key evil-visual-state-map (kbd "!") #'/eshell/new-window)
 (define-key evil-motion-state-map (kbd "!") #'/eshell/new-window)
 #+END_SRC

* Helm

#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'helm)

(setq helm-bookmark-show-location t)
(setq helm-buffer-max-length 40)
(setq helm-split-window-inside-p t)
(setq helm-mode-fuzzy-match t)
(setq helm-ff-file-name-history-use-recentf t)
(setq helm-ff-skip-boring-files t)
(setq helm-follow-mode-persistent t)

(after 'helm-source
  (defun /helm/make-source (f &rest args)
    (let ((source-type (cadr args))
          (props (cddr args)))
      (unless (child-of-class-p source-type 'helm-source-async)
        (plist-put props :fuzzy-match t))
      (apply f args)))
  (advice-add 'helm-make-source :around '/helm/make-source))
#+END_SRC


** Other helm settings

#+BEGIN_SRC emacs-lisp :tangle init.el
(after 'helm
  ;; take between 10-30% of screen space
  (setq helm-autoresize-min-height 10)
  (setq helm-autoresize-max-height 30)
  (helm-autoresize-mode t))
#+END_SRC

Make helm replace the default Find-File and M-x

#+BEGIN_SRC emacs-lisp :tangle init.el
   (progn
   (global-set-key [remap execute-extended-command] #'helm-M-x)
   (global-set-key [remap find-file] #'helm-find-files)
   (helm-mode t))
#+END_SRC

** Helm related bindings
   
#+BEGIN_SRC emacs-lisp :tangle init.el
(after 'helm
  (require 'helm-config)
  (global-set-key (kbd "C-c h") #'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))
  (global-set-key (kbd "C-h a") #'helm-apropos)
  (global-set-key (kbd "C-x b") #'helm-buffers-list)
  (global-set-key (kbd "C-x C-b") #'helm-mini)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
  (global-set-key (kbd "C-x r b") #'helm-bookmarks)
  (global-set-key (kbd "M-x") #'helm-M-x)
  (global-set-key (kbd "M-y") #'helm-show-kill-ring)
  (global-set-key (kbd "M-:") #'helm-eval-expression-with-eldoc)
  (define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z") #'helm-select-action)
)
#+END_SRC

* Dired

#+BEGIN_SRC emacs-lisp :tangle init.el
  (after 'dired
    (require 'dired-k)
    (setq dired-k-style 'git)
    (setq dired-k-human-readable t)
    (add-hook 'dired-initial-position-hook #'dired-k))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq dired-dwin-target t)
#+END_SRC

* Magit

** Load evil-magit with magit buffer

#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
(after 'magit
  (require 'evil-magit)
  (evil-magit-init))
#+END_SRC


** define global keybing to magit-status
   
#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-set-key (kbd "C-x g") 'magit-status)
#+END_SRC
   
* which-key

#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'which-key)
  (setq which-key-idle-delay 0.2)
  (setq which-key-min-display-lines 3)
  (setq which-key-max-description-length 20)
  (setq which-key-max-display-columns 6)
  (which-key-mode)
#+END_SRC

* General editor configuration
  
  
** Show line numbers
#+BEGIN_SRC emacs-lisp :tangle init.el
  (when (version<= "26.0.50" emacs-version )
    (global-display-line-numbers-mode))
#+END_SRC



** Line Number : Pretty format
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq linum-format " %d ")
#+END_SRC



** Use the system clipboard
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq x-select-enable-clipboard t)
#+END_SRC




** Window navigation with vim-like bindings

#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; for some readon the bellow lines should be the default native way for navigation on emacs
  ;; but they dont work
  ;; using the above package instead til i find a solution
  ;
  ;; (windmove-default-keybindings 'control)
  ;; (global-set-key (kbd "C-h") 'windmove-left)
  ;; (global-set-key (kbd "C-l") 'windmove-right)
  ;; (global-set-key (kbd "C-k") 'windmove-up)
  ;; (global-set-key (kbd "C-j") 'windmove-down)
#+END_SRC


Bellow i use the `define-keys` function to map window navigation to default Vim bindings <C-hjkl>

First require the file with the function

#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (require 'evil-tmux-navigator)
#+END_SRC


Then create the keybindings 
#+BEGIN_SRC emacs-lisp :tangle init.el
  (define-prefix-command 'evil-window-map)
  (define-key evil-window-map "h" 'evil-window-left)
  (define-key evil-window-map "j" 'evil-window-down)
  (define-key evil-window-map "k" 'evil-window-up)
  (define-key evil-window-map "l" 'evil-window-right)
  (define-key evil-window-map "b" 'evil-window-bottom-right)
  (define-key evil-window-map "c" 'evil-window-delete)
  (define-key evil-motion-state-map "\M-w" 'evil-window-map)
#+END_SRC

    
#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (/bindings/define-keys evil-normal-state-map
    ;; ("C-w h" #'evil-window-left)
    ;; ("C-w j" #'evil-window-down)
    ;; ("C-w k" #'evil-window-up)
    ;; ("C-w l" #'evil-window-right))
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (/bindings/define-keys evil-normal-state-map
  ;;   ("C-w h" #'evil-window-left)
  ;;   ("C-w j" #'evil-window-down)
  ;;   ("C-w k" #'evil-window-up)
  ;;   ("C-w l" #'evil-window-right))
#+END_SRC


** Increase, decrease and adjust font size

#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-set-key (kbd "C-+") #'text-scale-increase)
  (global-set-key (kbd "C-_") #'text-scale-decrease)
  ;; (global-set-key (kbd "C-)") #'text-scale-adjust)
#+END_SRC

* General text editing settings

** Turn on auto-revert mode (auto updates files changed on disk)
#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-auto-revert-mode 1)
  (setq auto-revert-interval 0.5)
#+END_SRC

  
** Spellchecking
#+BEGIN_SRC emacs-lisp :tangle init.el
(defconst *spell-check-support-enabled* t) ;; Enable with t if you prefer
#+END_SRC

*** I recommend adding this to your .emacs, as it makes C-n insert newlines if the point is at the end of the buffer. Useful, as it means you won’t have to reach for the return key to add newlines!
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq next-line-add-newlines t)
#+END_SRC


** Smartscan mode
: Usage:
: M-n and M-p move between symbols
: M-' to replace all symbols in the buffer matching the one under point
: C-u M-' to replace symbols in your current defun only (as used by narrow-to-defun.)

#+BEGIN_SRC emacs-lisp :tangle init.el
  (smartscan-mode 1)
#+END_SRC


** PDF Tools

*** Install pdf-tools if its not already installed
#+BEGIN_SRC emacs-lisp :tangle init.el
   (pdf-tools-install)
#+END_SRC


*** Make buffer refresh every 1 second to PDF-tools updates the changed pdf
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
  ;; (add-hook 'pdf-view-mode-hook 'auto-revert-mode) 
  ;; (add-hook 'doc-view-mode-hook 'auto-revert-mode) 
#+END_SRC


*** PDF tools evil keybindings
#+BEGIN_SRC emacs-lisp :tangle init.el
  (evil-define-key 'normal pdf-view-mode-map
    "h" 'pdf-view-previous-page-command
    "j" (lambda () (interactive) (pdf-view-next-line-or-next-page 5))
    "k" (lambda () (interactive) (pdf-view-previous-line-or-previous-page 5))
    "l" 'pdf-view-next-page-command)
#+END_SRC

* Development environment customizations
  
  
  
** Show matching parenthesis
#+BEGIN_SRC emacs-lisp :tangle init.el
  ; parentheses
  (show-paren-mode t)
#+END_SRC



** indentation
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq-default indent-tabs-mode nil)
  (setq-default c-basic-offset 2)
#+END_SRC


** enable rainbow-mode on relevant filetypes

Colorize hex, rgb and named color codes
   
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'org-mode-hook 'rainbow-mode)
  (add-hook 'css-mode-hook 'rainbow-mode)
  (add-hook 'php-mode-hook 'rainbow-mode)
  (add-hook 'html-mode-hook 'rainbow-mode)
  (add-hook 'web-mode-hook 'rainbow-mode)
  (add-hook 'js2-mode-hook 'rainbow-mode)
#+END_SRC

* Appearance

  
** Applying my theme
   
#+BEGIN_SRC emacs-lisp :tangle init.el

  (add-to-list 'custom-theme-load-path "~/dotfiles/emacs.d/themes/")
  ; theme options:
  ; atom-one-dark (doenst work well with emacsclient, ugly blue bg)
  ; dracula
  ; darktooth
  ; gruvbox-dark-hard
  ; gruvbox-dark-light
  ; gruvbox-dark-medium
  ; base16-default-dark-theme <-- this one is good

  (setq my-theme 'dracula)
  
#+END_SRC

Load the theme

#+BEGIN_SRC emacs-lisp :tangle init.el
 (load-theme my-theme t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle init.el

  ;; (defun load-my-theme (frame)
  ;;   "Function to load the theme in current FRAME.
  ;;   sed in conjunction
  ;;   with bellow snippet to load theme after the frame is loaded
  ;;   to avoid terminal breaking theme."
  ;;   (select-frame frame)
  ;;   (load-theme my-theme t))

  ;; ; make emacs load the theme after loading the frame
  ;; ; resolves issue with the theme not loading properly in terminal mode on emacsclient

  ;; ;; this if was breaking my emacs!!!!!
  ;;  (add-hook 'after-make-frame-functions #'load-my-theme)
#+END_SRC



** Customizing the mode line

#+BEGIN_SRC emacs-lisp :tangle init.el
 (require 'smart-mode-line)
 (if (require 'smart-mode-line nil 'noerror)
     (progn
       ;( sml/name-width 20)
       ;( sml/mode-width 'full)
       ;( sml/shorten-directory t)
       ;( sml/shorten-modes t)
       (require 'smart-mode-line-powerline-theme)
       ; this must be BEFORE (sml/setup)
       (sml/apply-theme 'powerline)
       ;; Alternatives:
       ;; (sml/apply-theme 'powerline)
       ;; (sml/apply-theme 'dark)
       ;; (sml/apply-theme 'light)
       ;; (sml/apply-theme 'respectful)
       ;; (sml/apply-theme 'automatic)


       (if after-init-time
           (sml/setup)
         (add-hook 'after-init-hook 'sml/setup))


       (display-time-mode 1)
      
       (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
       (add-to-list 'sml/replacer-regexp-list
                    '("^~/.*/lib/ruby/gems" ":GEMS" ))
       (add-to-list 'sml/replacer-regexp-list
                    '("^~/Projects/" ":CODE:"))))
#+END_SRC

* Minor modes

  
** js2-refactor

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'js2-mode-hook #'js2-refactor-mode)
#+END_SRC


*** choose js2-refactor keybinding scheme (this can be changed easily)

#+BEGIN_SRC emacs-lisp :tangle init.el
  (js2r-add-keybindings-with-prefix "C-c C-m")
#+END_SRC


** web-mode
   
*** Require Web-Mode
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'web-mode)
#+END_SRC

*** HTML element offset indentation
 #+BEGIN_SRC emacs-lisp :tangle init.el
 (setq web-mode-markup-indent-offset 2)
 #+END_SRC

*** CSS offset indentation
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq web-mode-css-indent-offset 2)
#+END_SRC

*** Script/code offset indentation (for JavaScript, Java, PHP, Ruby, Go, VBScript, Python, etc.)
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq web-mode-code-indent-offset 2)
#+END_SRC


** diff-hl (highlights uncommited diffs in bar aside from the line numbers)
(global-diff-hl-mode)

** smartparens
#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'smartparens-config)
(add-hook 'prog-mode-hook #'smartparens-mode)
#+END_SRC

*** evil-smartparens helps avoid conflicts between evil and smartparens

#+BEGIN_SRC emacs-lisp :tangle init.el
(add-hook 'smartparens-enabled-hook #'evil-smartparens-mode)
#+END_SRC



* File associations

   
** Languages File Types (this type of association only works with Major Modes)
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
#+END_SRC

** Using web-mode for editing plain HTML files can be done this way
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
#+END_SRC

* FlyCheck linter

#+BEGIN_SRC emacs-lisp :tangle init.el
(add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

** Turn flycheck inline extension after flycheck starts
   
#+BEGIN_SRC emacs-lisp :tangle init.el
  (with-eval-after-load 'flycheck
    (global-flycheck-inline-mode))
  ;; (with-eval-after-load 'flycheck
  ;;   (add-hook 'flycheck-mode-hook #'turn-on-flycheck-inline))
#+END_SRC

* Emmets
    
    
** Add hook to any markup file to load emmet-mode
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
  (add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation. 
#+END_SRC

** Use emmet with JSX markup
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq emmet-expand-jsx-className? t) ;; default nil
#+END_SRC

* Autocompletion and Snippets
  
** Disable <RET> for autocomplete and leave on TAB
#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (define-key ac-completing-map [return] nil)
  ;; (define-key ac-completing-map "\r" nil)
#+END_SRC
  

** enable autocompletion engine
#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'auto-complete)
(global-auto-complete-mode t)
#+END_SRC


** Company mode (Complete Anything)
   
*** Basic settings for company-mode
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'company)
  (global-company-mode t)
  (setq company-tooltip-limit 20)                      ; bigger popup window
  (setq company-minimum-prefix-length 1)               ; start completing after 1st char typed
  (setq company-idle-delay .1)                         ; decrease delay before autocompletion popup shows
  (setq company-echo-delay 0)                          ; remove annoying blinking
  (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
  (setq company-dabbrev-downcase nil)                  ; Do not convert to lowercase
  (setq company-dabbrev-ignore-case t)
  (setq company-dabbrev-code-everywhere t)
  (setq company-selection-wrap-around t)               ; continue from top when reaching bottom
  (setq company-auto-complete 'company-explicit-action-p)
#+END_SRC

*** Enable company-mode in all buffers
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC
(add

*** Bind <TAB> to company-indent-or-complete
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook 'global-company-mode)

  (after "company-autoloads"
     (define-key evil-insert-state-map (kbd "TAB")
       #'company-indent-or-complete-common))
#+END_SRC


** Yasnippets

#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (add-to-list 'load-path
  ;;               "~/.emacs.d/plugins/yasnippet")
  (require 'yasnippet)
  (yas-global-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq yas-snippet-dirs
      '("~/.emacs.d/snippets"                 ;; personal snippets
        ))
#+END_SRC


* JavaScript
   
** PrettierJS

   
*** Require first so i can actually use it

 #+BEGIN_SRC emacs-lisp :tangle init.el
   (require 'prettier-js)
 #+END_SRC
  
*** add prettier to js2 and rjsx minor modes

 #+BEGIN_SRC emacs-lisp :tangle init.el
   (add-hook 'js2-mode-hook 'prettier-js-mode)
   (add-hook 'web-mode-hook 'prettier-js-mode)
   (add-hook 'rjsx-mode-hook 'prettier-js-mode)
 #+END_SRC

*** Add prettier to Web-Mode
 #+BEGIN_SRC emacs-lisp :tangle init.el
 (defun enable-minor-mode (my-pair)
   "Enable minor mode if filename match the regexp.  MY-PAIR is a cons cell (regexp . minor-mode)."
   (if (buffer-file-name)
       (if (string-match (car my-pair) buffer-file-name)
       (funcall (cdr my-pair)))))
 #+END_SRC

**** And then hook to web-mode like this:

 #+BEGIN_SRC emacs-lisp :tangle init.el
 (add-hook 'web-mode-hook #'(lambda ()
                             (enable-minor-mode
                              '("\\.js?\\'" . prettier-js-mode)
                              '("\\.jsx?\\'" . prettier-js-mode)
                              '("\\.css?\\'" . prettier-js-mode))))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :tangle init.el
   ;; (require 'ruby.tau)
   (add-to-list 'auto-mode-alist '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode))
 #+END_SRC

 
* HTML
   
  
* YAML Mode
  
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
#+END_SRC


** Unlike python-mode, this mode follows the Emacs convention of not binding the ENTER key to `newline-and-indent'.  To get this behavior, add the key definition to `yaml-mode-hook':

#+BEGIN_SRC emacs-lisp :tangle init.el
    (add-hook 'yaml-mode-hook
      '(lambda ()
        (define-key yaml-mode-map "\C-m" 'newline-and-indent))) 
#+END_SRC

* Elixir
   
** Install elixir-mode if not already installed
    
#+BEGIN_SRC emacs-lisp :tangle init.el
  (unless (package-installed-p 'elixir-mode)
  (package-install 'elixir-mode))  
#+END_SRC

** Require elixir-mode
    
#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'elixir-mode)
#+END_SRC

** Enable elixir-mode for appropriate file extensions
#+BEGIN_SRC emacs-lisp :tangle init.el
(add-to-list 'auto-mode-alist '("\\.ex\\'" . elixir-mode))
(add-to-list 'auto-mode-alist '("\\.exs\\'" . elixir-mode))
;; Use web-mode for elixir template files (eex)
(add-to-list 'auto-mode-alist '("\\.eex\\'" . web-mode))
#+END_SRC

** Create a buffer-local hook to run elixir-format on save, only when we enable elixir-mode.
   
#+BEGIN_SRC emacs-lisp :tangle init.el
 (add-hook 'elixir-mode-hook
           (lambda () (add-hook 'before-save-hook 'elixir-format nil t)))
#+END_SRC
          
 
* Ruby
  

This Ruby part of the config compiles to a separate file, inside the config folder, called `ruby.tau.el`

#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
  (require 'ruby-mode)
#+END_SRC



** auto load enh ruby mode for all common ruby files
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(add-to-list 'auto-mode-alist
             '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode))
#+END_SRC

** this bellow is optional, i only use it because it complains about not finding ruby in /usr/local/bin
"This is also easily solvable by creating a symbolic link to the ruby shim to /usr/local/bin/ruby
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(setq enh-ruby-program "~/.rbenv/shims/ruby") ; so that still works if ruby points to ruby1.8
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(setq-default
  ruby-use-encoding-map nil
  ruby-insert-encoding-magic-comment nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(after 'enh-ruby-mode
            ;; Stupidly the non-bundled ruby-mode isn't a derived mode of
            ;; prog-mode: we run the latter's hooks anyway in that case.
            (add-hook 'ruby-mode-hook
                      (lambda ()
                        (unless (derived-mode-p 'prog-mode)
                          (run-hooks 'prog-mode-hook)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(add-hook 'enh-ruby-mode-hook 'subword-mode)
#+END_SRC


** Enhanced Ruby Mode defines its own specific faces with the hook erm-define-faces. If your theme is already defining those faces, to not overwrite them, just remove the hook with:
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(remove-hook 'enh-ruby-mode-hook 'erm-define-faces)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(after 'page-break-lines
            (push 'ruby-mode page-break-lines-modes))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(require 'rspec-mode)
#+END_SRC


** Inferior ruby
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(require 'inf-ruby)
(add-hook 'enh-ruby-mode-hook 'inf-ruby-minor-mode)
#+END_SRC


** Ruby compilation
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(require 'ruby-compilation)

(after 'enh-ruby-mode
            (let ((m ruby-mode-map))
              (define-key m [S-f7] 'ruby-compilation-this-buffer)
              (define-key m [f7] 'ruby-compilation-this-test)))

(after 'ruby-compilation
            (defalias 'rake 'ruby-compilation-rake))
#+END_SRC


** Robe mode
Dependencies:   
- opry
- pry-doc >= 0.6.0 (on MRI)
- method_source >= 0.8.2 (for compatibility with the latest Rubinius)

/Note that if your project is using Bundler, the dependencies have to be added to the Gemfile./
*** Enable robe-mode upon enh-ruby-mode
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(add-hook 'enh-ruby-mode-hook 'robe-mode)   
#+END_SRC

*** Company completion for Robe
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(eval-after-load 'company
  '(push 'company-robe company-backends))
#+END_SRC

*** native autocomplete with robe
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(add-hook 'robe-mode-hook 'ac-robe-setup)
#+END_SRC


** ri support
#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
;; (require 'yari)
;; (defalias 'ri 'yari)
#+END_SRC



#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(require 'goto-gem)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(require 'bundler)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(when (maybe-require 'yard-mode)
  (add-hook 'ruby-mode-hook 'yard-mode)
  (add-hook 'enh-ruby-mode-hook 'yard-mode)
  (after 'yard-mode
              (diminish 'yard-mode)))
#+END_SRC

*** Rubocop
 #+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
 (require 'rubocop)
 #+END_SRC



#+BEGIN_SRC emacs-lisp :tangle config/ruby.tau.el
(provide 'ruby.tau)
;;; ruby.tau ends here
#+END_SRC




* PHP
  
#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (autoload 'php-mode "php-mode" "Major mode for editing PHP code." t)
  ;; (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
  ;; (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode))
#+END_SRC


* Go
#+BEGIN_SRC emacs-lisp :tangle init.el
; (autoload 'go-mode "go-mode" "Major mode for editing Go code." t)
; (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
#+END_SRC


* Markdown
#+BEGIN_SRC emacs-lisp :tangle init.el
  (autoload 'mardown-mode "markdown-mode")
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC


* Haskell
#+BEGIN_SRC emacs-lisp :tangle init.el
; ; (require 'haskell-interactive-mode)
; (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
; (eval-after-load 'flycheck
;                  '(add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
; (add-hook 'haskell-mode-hook (lambda ()
;                                (electric-indent-mode -1)))
; (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
; (add-hook 'haskell-mode-hook (lambda () (global-set-key (kbd "<f5>") 'haskell-process-cabal-build)))
#+END_SRC

* LaTeX

#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'ox-latex)
#+END_SRC

** AucTex settings

#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'tex)
#+END_SRC

Three steps are required (as according to ORG official docs) to setup AucTex with Emacs:

*** 1) Tell emacs where the LaTeX related bins are located in the system

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq exec-path (append exec-path '("/usr/bin/tex")))
#+END_SRC

*** 2) Load AucTex
    
#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (load "auctex.el" nil t t)
  ;; (load "preview-latex.el" nil t t)
#+END_SRC

*** 3) Add Latex to list of org-babel loaded languages
    
#+END_SRC
 #+BEGIN_SRC emacs-lisp :tangle init.el
 (org-babel-do-load-languages
  'org-babel-load-languages
  '((latex . t)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :tangle init.el
     (setq TeX-auto-save t)
     (setq TeX-parse-self t)
     (setq-default TeX-master nil)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp :tangle init.el
     (add-hook 'LaTeX-mode-hook 'visual-line-mode)
     (add-hook 'LaTeX-mode-hook 'flyspell-mode)
     (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)   
 #+END_SRC




** Latex Classes
*** Add the beamer presentation class template to org
 #+BEGIN_SRC emacs-lisp :tangle init.el
  (add-to-list 'org-latex-classes
	       '("beamer"
	         "\\documentclass\[presentation\]\{beamer\}"
	         ("\\section\{%s\}" . "\\section*\{%s\}")
	         ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
	         ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))
 #+END_SRC


*** Add the memoir class template to org
    
The Sections and Heading Levels gets configured as follows: 

    | Division       | <c>Level | <c>org-equivalent |
    | \book          |       -2 | *                 |
    | \part          |       -1 | **                |
    | \chapter       |        0 | ***               |
    | \section       |        1 | ****              |
    | \subsection    |        2 | *****             |
    | \subsubsection |        3 | ******            |
    | \paragraph     |        4 | *******           |
    | \subparagraph  |        5 | ********          |

    
#+BEGIN_SRC emacs-lisp :tangle init.el
   (add-to-list 'org-latex-classes
                '("memoir"
                  "\\documentclass\[a4paper\]\{memoir\}"
                  ("\\book\{%s\}" . "\\book*\{%s\}")
                  ("\\part\{%s\}" . "\\part*\{%s\}")
                  ("\\chapter\{%s\}" . "\\chapter*\{%s\}")
                  ("\\section\{%s\}" . "\\section*\{%s\}")
                  ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
                  ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))
#+END_SRC

*** Add abntex2 class to org list of latex classes
This class is based on the Memoir class
The Sections and Heading Levels gets configured as follows: 

    | Division       | <c>Level | <c>org-equivalent |
    | \part          |       -1 | *                 |
    | \chapter       |        0 | **                |
    | \section       |        1 | ***               |
    | \subsection    |        2 | ****              |
    | \subsubsection |        3 | *****             |
    | \paragraph     |        4 | ******            |
    | \subparagraph  |        5 | *******           |
#+BEGIN_SRC emacs-lisp :tangle init.el
   (add-to-list 'org-latex-classes
             '("abntex2"
               "\\documentclass{abntex2}"
               ("\\part{%s}" . "\\part*{%s}")
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\subsubsubsection{%s}" . "\\subsubsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}"))
             ) 
#+END_SRC

 
** Enable latex-preview-pane
#+BEGIN_SRC emacs-lisp :tangle init.el
   (latex-preview-pane-enable)
#+END_SRC

** To compile documents to PDF by default add the following to your ~/.emacs.

#+BEGIN_SRC emacs-lisp :tangle init.el
     (setq TeX-PDF-mode t)
#+END_SRC

*** If it doesn’t work, try this :

#+BEGIN_SRC emacs-lisp :tangle init.el
     (TeX-global-PDF-mode t)
#+END_SRC


** To highlight (or font-lock) the “\section{title}” lines:

#+BEGIN_SRC emacs-lisp :tangle init.el
(font-lock-add-keywords
   'latex-mode
   `((,(concat "^\\s-*\\\\\\("
               "\\(documentclass\\|\\(sub\\)?section[*]?\\)"
               "\\(\\[[^]% \t\n]*\\]\\)?{[-[:alnum:]_ ]+"
               "\\|"
               "\\(begin\\|end\\){document"
               "\\)}.*\n?")
      (0 'your-face append))))
#+END_SRC


** Convert quotes to LaTeX Smartquotes
   
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq org-export-with-smart-quotes t)
#+END_SRC

** Keep latex logfiles
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq org-latex-remove-logfiles nil)
#+END_SRC

* Helper functions

  
** Copy/Paste To/From System's Clipboard =D
    
   
*** Copy
    
#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun copy-to-clipboard ()
    "Make F8 and F9 Copy and Paste to/from OS Clipboard.  Super usefull."
    (interactive)
    (if (display-graphic-p)
	(progn
	  (message "Yanked region to x-clipboard!")
	  (call-interactively 'clipboard-kill-ring-save)
	  )
      (if (region-active-p)
	  (progn
	    (shell-command-on-region (region-beginning) (region-end) "xsel -i -b")
	    (message "Yanked region to clipboard!")
	    (deactivate-mark))
	(message "No region active; can't yank to clipboard!")))
    )
#+END_SRC


*** Paste
    
#+BEGIN_SRC emacs-lisp :tangle init.el
  (evil-define-command paste-from-clipboard()
    (if (display-graphic-p)
	(progn
	  (clipboard-yank)
	  (message "graphics active")
	  )
      (insert (shell-command-to-string "xsel -o -b")) ) )
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-set-key [f9] 'copy-to-clipboard)
  (global-set-key [f10] 'paste-from-clipboard)
#+END_SRC


** Auto save function

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun my-save ()
    "Save file when leaving insert mode in Evil."
    (if (buffer-file-name)
	(evil-save)))
#+END_SRC

*** This hook to the above function was breaking the evil-esc-delay 0
#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (add-hook 'evil-insert-state-exit-hook 'my-save)
#+END_SRC



#+BEGIN_SRC emacs-lisp :tangle init.el
;; Local Variables:
;; coding: utf-8
;; no-byte-compile: t
;; End:


(provide 'init)
;;; .emacs ends here

#+END_SRC

* Provide packages in separate files

  
** Provide the evil.tau.el file
   
#+BEGIN_SRC emacs-lisp :tangle config/evil.tau.el
  (provide 'evil.tau)
  ;;; evil.tau.el ends here...
#+END_SRC

** Provide the org.tau.el file

#+BEGIN_SRC emacs-lisp :tangle config/org.tau.el
  (provide 'org.tau)
  ;;; org.tau.el ends here...
#+END_SRC













