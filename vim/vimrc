""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" my vim setup
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""



" Auto install vim-plug and Plugins
let vimplug_exists=expand('~/.vim/autoload/plug.vim')
let vimplug_plugins_dir=expand('~/.vim/plugged')

if !filereadable(vimplug_exists)
  if !executable("curl")
    echoerr "You have to install curl or first install vim-plug yourself!"
    execute "q!"
  endif
  echo "Installing Vim-Plug..."
  echo ""
  silent exec "!\curl -fLo " . vimplug_exists . " --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
  let g:not_finish_vimplug = "yes"

  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

call plug#begin(vimplug_plugins_dir)

Plug 'neoclide/coc.nvim', {'branch': 'release'}

" if has('nvim')
"   :Plug 'neovim/nvim-lsp'
" endif

" Linting
" Plug 'w0rp/ale'

" Snippets
Plug 'honza/vim-snippets'

" vim which key on-demand lazy load
Plug 'liuchengxu/vim-which-key', { 'on': ['WhichKey', 'WhichKey!'] }

" UI / Colorscheme / tema
Plug 'tomasiser/vim-code-dark'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'chrisbra/Colorizer'                " Show hex codes as colours

" Vim Airline statusbar
" Plug 'vim-airline/vim-airline'
" Plug 'vim-airline/vim-airline-themes'
" Plug 'mkitt/tabline.vim'                 " Cleaner tabs

" Rainbow Parentheses Improved
Plug 'luochen1990/rainbow'

Plug 'ryanoasis/vim-devicons'            " Icons for dev file types. Has to be loaded after airline

" File explorers
Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'francoiscabrol/ranger.vim'         " Install ranger-vim integration with ranger file manager

" Tim Pope's general plugins
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'                  " so that vim-surroud actions will be repeatable with dot command .
Plug 'tpope/vim-commentary'              " use with 'gc', equivalent to vscode ctrl+/)
Plug 'tpope/vim-rsi'
Plug 'terryma/vim-multiple-cursors'       " Install vim-multiple-cursors (equivalent to vscode ctrl+d)
Plug 'unblevable/quick-scope'            " Highlight jump characters
Plug 'RRethy/vim-illuminate'             " illuminate other uses of current word under cursor


" Git interfaces
Plug 'tpope/vim-git'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'


Plug 'pbrisbin/vim-runfile'

" jump to matching pairs and highlight them (modern replacement for matchit and matchparen)
Plug 'andymass/vim-matchup'

Plug 'terryma/vim-expand-region'

Plug 'valloric/MatchTagAlways'           " Show matching and closing tags

" FZF
if isdirectory('/usr/local/opt/fzf')
  Plug '/usr/local/opt/fzf' | Plug 'junegunn/fzf.vim'
else
  Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }
  Plug 'junegunn/fzf.vim'
endif

Plug 'gabesoft/vim-ags' " ag, rg support

Plug 'tpope/vim-eunuch' " Vim sugar for the UNIX shell commands, like :Delete to delete buffer and file at same time, SudoWrite, etc...
Plug 'ntpeters/vim-better-whitespace' " Highlight trailing whitespace
Plug 'sheerun/vim-polyglot' " Syntax highliht, indent and filetype plugin support for several languages

Plug 'christoomey/vim-tmux-navigator'

Plug 'junegunn/vim-easy-align'

" Languages Plugins

" React
Plug 'mxw/vim-jsx' " JSX syntax colors and indent support. Depends on vim-javascript
Plug 'xojs/vim-xo' " Install vim-xo for xo linting support
Plug 'prettier/vim-prettier', { 'do': 'npm install' }
Plug 'editorconfig/editorconfig-vim'

" Javascript and Typescript
Plug 'pangloss/vim-javascript'
Plug 'jelera/vim-javascript-syntax' " used in vim-boostrap

" typescript
Plug 'leafgarland/typescript-vim' " used by vim-boostrap
Plug 'HerringtonDarkholme/yats.vim'
" Plug 'heavenshell/vim-tslint'

" Go
Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }

" Elixir
Plug 'elixir-editors/vim-elixir'
Plug 'carlosgaldino/elixir-snippets'
Plug 'slashmili/alchemist.vim'
Plug 'mhinz/vim-mix-format'

" erlang
Plug 'jimenezrick/vimerl'

" haskell
Plug 'eagletmt/neco-ghc'
Plug 'dag/vim2hs'
Plug 'pbrisbin/vim-syntax-shakespeare'

" Ruby
Plug 'vim-ruby/vim-ruby'
Plug 'tpope/vim-rails'
Plug 'tpope/vim-rake'
Plug 'sunaku/vim-ruby-minitest'
Plug 'thoughtbot/vim-rspec'
Plug 'tpope/vim-bundler'
Plug 'ecomba/vim-ruby-refactoring'

" rust
Plug 'racer-rust/vim-racer'
Plug 'rust-lang/rust.vim'

" html
Plug 'hail2u/vim-css3-syntax'
Plug 'gorodinskiy/vim-coloresque'
Plug 'tpope/vim-haml'
Plug 'mattn/emmet-vim'

" Markdown
Plug 'plasticboy/vim-markdown'
Plug 'suan/vim-instant-markdown'         " Markdown preview instant-markdown-
Plug 'godlygeek/tabular'                 " Tabular align texts that grow


call plug#end() " Initialize plugin system

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if !has('nvim')
  set nocompatible                     " not compatible with Vi
  filetype plugin indent on            " mandatory for modern plugins
  syntax on                            " enable syntax highlighting
  set autoindent                       " copy indent from the previous line
  set autoread                         " reload from disk
  set backspace=indent,eol,start       " modern backspace bhaviour
  set background dark
  set belloff=all                      " disable the bell
  set cscopeverbose                    " bservose cscope output
  set complete-=i                      " don't scan current on included files for completion
  set display =lastline,msgsep         " display more message text
  set encofing=utf-8                   " set default encoding
  " set fillchars=vert:|,fold          " separator characters
  set fillchars=vert:|                 " separator characters
  set formatoptions=tcqj               " more intuitive autoformatting
  set fsync                            " call fsync() for robust file saving
  set history=10000                    " longest possible command history
  set hlsearch                         " highlihgt search results
  set incsearch                        " move cursor as you type when searching
  set langnoremap                      " helps avoid mapings breaking
  set laststatus=2                     " always display a status line
  set listchars=tab:>\ ,trail:-,nbsp:+ " chars for :list
  set nrformats=bin,hex                " <c-a> and <c-x> support
  set ruler                            " display current line # in a corner
  set sessionsoptions-=options         " do not carry options across sessions
  set shortmess=F                      " less verbose file info
  set showcmd                          " show last command in the status line
  set sidescroll=1                     " smoother sideways scrolling
  set smarttab                         " tab settings aware <Tab> key
  set tabpagemax=50                    " maximum number of tabs open by -p flag
  set tags=./tags;,tags                " filenames to look for the tag command
  set ttimeoutlen=50                   " ms to wait for next key in a sequence
  set ttyfast                          " indicates that out connection is fast
  set viminfo+=!                       " save global variables across sessions
  set wildmenu                         " enhanced command line completion
endif


let g:mapleader =      "\<Space>"
let g:maplocalleader = ","


set ffs=unix,dos,mac   " Use Unix as the standard file type
set autochdir          " set current directory to recently opened file

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" terminal and shell configuration

set t_Co=256 " use 256 colors (needed by the colorschemes)

if exists('$SHELL')
  set shell=$SHELL
else
  set shell=/bin/sh
endif

if !has('nvim')
  set ttyfast
endif

set termguicolors
let $LANG='en'  " Avoid garbled characters in Chinese language windows OS
set langmenu=en


nnoremap <silent> <leader>sh :terminal<CR> " terminal emulation

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" command-line completion

set wildmode=full    " command-line completion enhanced mode
" set wildmode=list:longest  " Make wildmenu behave like bash completion. Finding commands are so easy now.
set wildoptions+=pum " use popupmenu for wildmode completion
set wildoptions+=tagfile
set cmdheight=2      " Height of the command bar

" List of files to be ignored in command line completions for file and dir names
set wildignore+=*.ai,*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.png,*.psd,*.webp
set wildignore+=*.aux,*.out,*.toc
set wildignore+=*.avi,*.divx,*.mp4,*.webm,*.mov,*.m2ts,*.mkv,*.vob,*.mpg,*.mpeg
set wildignore+=*.doc,*.pdf,*.cbr,*.cbz,*.docx,*.ppt,*.odt
set wildignore+=*.eot,*.otf,*.ttf,*.woff
set wildignore+=*.mp3,*.oga,*.ogg,*.wav,*.flac
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest,*.rbc,*.class,*.jar,*.iso
set wildignore+=*.swp,.lock,.DS_Store,._*
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz,*.kgb
set wildignore+=.git,.hg,.svn
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc,*.db,*.sqlite


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" search related settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set hlsearch   " Highlight search results
set incsearch  " Searches for strings incrementally
set ignorecase " Always search case-insensitive
set smartcase  " case insensitive search if all lowercase


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" session settings

let g:session_directory = "~/.config/nvim/session"
let g:session_autoload = "no"
let g:session_autosave = "no"
let g:session_command_aliases = 1

nnoremap <leader>so :OpenSession<Space>
nnoremap <leader>ss :SaveSession<Space>
nnoremap <leader>sd :DeleteSession<CR>
nnoremap <leader>sc :CloseSession<CR>
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set shortmess+=c " Don't pass messages to |ins-completion-menu|.
set display+=lastline
if has('nvim')
	set display+=msgsep "  minimize scrolling when showing messages
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Buffer settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set hidden " Enable hidden buffers. Coc Observation about this: TextEdit might fail if hidden is not set.
set hid  " A buffer becomes hidden when it is abandoned
set switchbuf=useopen  " don't duplicate an existing open buffer

nnoremap <leader>bl :Buffers<CR> " List buffers
noremap <leader>bp :bprevious<CR> " previous buffer
noremap <leader>bn :bnext<CR> " next buffer
map <leader>bc :Bclose<cr>:tabclose<cr>gT " Close the current buffer
" noremap <leader>bc :bdelete<CR>
map <leader>ba :bufdo bd<cr> " Close all the buffers
map <leader>cd :cd %:p:h<cr>:pwd<cr> " Switch CWD to the directory of the open buffer

" Opens a new tab with the current buffer's path
map <leader>te :tabedit <c-r>=expand("%:p:h")<cr>/

"" Opens an edit command with the path of the currently edited file filled in
noremap <leader>ty :e <C-R>=expand("%:p:h") . "/" <CR>

" Specify the behavior when switching between buffers
try
  set switchbuf=useopen,usetab,newtab
  set stal=2
catch
endtry


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Cursor Settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Substitute live preview in a split window

if has('nvim')
  set inccommand=split " show live results for some commands (like :s) in a split window
endif

set scrolloff=1000           " Always show N lines above/below the cursor

" change cursor shape according to mode
autocmd VimEnter * silent exec "! echo -ne '\e[1 q'"
autocmd VimLeave * silent exec "! echo -ne '\e[5 q'"

set scrolloff=3 " vim-boostrap uses like this, dunno why
set scrolloff=7  " Set 7 lines to the cursor - when moving vertically using j/k

"" Disable the blinking cursor.
set guicursor=a:blinkon0

"" Remember cursor position
augroup vimrc-remember-cursor-position
  autocmd!
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
augroup END

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Clipboard
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set paste               " Paste from a windows or from vim
set go+=a               " Visual selection automatically copied to the clipboard

" from vim boostarp
if has('unnamedplus')
  set clipboard=unnamed,unnamedplus
endif

" set clipboard=unnamed
" " set clipboard=unnamedplus

"" Copy/Paste/Cut
if has('unnamedplus')
  set clipboard=unnamed,unnamedplus
endif

noremap YY "+y<CR>
noremap <leader>p "+gP<CR>
noremap XX "+x<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set whichwrap+=<,>,h,l,[,]     " wrap movement whenreaching startor endofline
set lazyredraw                 " Don't redraw while executing macros (good performance config)
set magic                      " For regular expressions turn magic on


"#########################################################################
" UI related settings
"#########################################################################

syntax on
set cursorline              " Highlight cursor line

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Colorscheme Section
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Download tomorrow night eighties colorscheme if not present
if empty(glob('~/.config/nvim/colors/Tomorrow-Night-Eighties.vim'))
  silent !curl -fLo ~/.config/nvim/colors/Tomorrow-Night-Eighties.vim --create-dirs
    \ https://raw.githubusercontent.com/chriskempson/vim-tomorrow-theme/master/colors/Tomorrow-Night-Eighties.vim
  autocmd VimEnter * source $MYVIMRC
endif

" Download codedark colorscheme if not present
if empty(glob('~/.config/vim/colors/codedark.vim'))
  silent !curl -fLo ~/.config/vim/colors/codedark.vim --create-dirs
    \ https://raw.githubusercontent.com/tomasiser/vim-code-dark/master/colors/codedark.vim
  autocmd VimEnter * source $MYVIMRC
endif

if empty($DISPLAY)
  colorscheme default
else
  colorscheme Tomorrow-Night-Eighties
  " colorscheme codedark
  " colorscheme gruvbox
  " let g:gruvbox_contrast_dark='hard'
endif

" Transparent backgroud
" highlight Normal ctermbg=NONE guibg=NONE

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set noshowmode " Hide insertStatus (like --INSERT--) fromthe statsline

set belloff=all  " No annoying sound on errors
set visualbell   " Use visual bell (no beeping)
set t_vb=

set timeoutlen=500 " The time in milliseconds that is waited for a key code or mapped key sequence to complete.
set ttimeoutlen=0  " ttimeoutlen is used for key code delays


set foldcolumn=1 " Add a bit extra margin to the left
set number                  " Show line numbers
set relativenumber     " show line numbers relative to current line


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Mouse related settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Enable mouse. see :help mouse for info.
set mouse=a

" settings to fix the mouse issue on alacritty terminal
if has('nvim')
  " set ttymouse=sgr
endif

" set ttymouse=xterm2


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Permite mover o cursor onde não há texto
set virtualedit=insert,block,onemore

" Highlight matching pairs
set showmatch

" How many tenths of a second to blink when matching brackets
set matchtime=2

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" PUM (PopUp Menu)- pseudo-transparent popup menu
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if has('nvim')
  set pumblend=11
endif

set pumheight=10


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SYNTAX HIGHLIGHTING
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" enables native filetype syntax highlighting base on file type
filetype on

filetype plugin on

if has('autocmd')
  filetype plugin indent on
endif

" enable syntax highlighting
if has('syntax') && !exists('g:syntax_on')
  syntax enable
endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" INDENTATION
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

filetype indent on
set autoindent               " Auto-indent new lines
set smartindent             " Enable smart-indent
set expandtab  " Use spaces instead of tabs
set shiftwidth=2  " Number of auto-indent spaces
set tabstop=2
set softtabstop=4           " Number of spaces per Tab

" Auto indent files on save and in open
" autocmd BufWritePre,BufRead * :normal gg=G
" Example of how to do it with specific file types
" autocmd BufWritePre,BufRead *.html :normal gg=G


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Undo | Redo
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set history=10000  " Sets how many lines of history VIM has to remember
set undolevels=1500            " Number of undo levels

"" Persistent Undo
if !isdirectory($HOME."/.config/vim/undo-dir")
  call mkdir($HOME."/.config/vim/undo-dir", "", 0700)
endif
set undodir=~/.config/vim/undo-dir
set undofile



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" My Custom Bindings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Which key
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" which key activate on leader press
nnoremap <silent> <leader> :<c-u>WhichKey '<Space>'<CR>
nnoremap <silent> <localleader> :<c-u>WhichKey ','<CR>


" quicly edit/reload configuration file
nnoremap cfo :e $MYVIMRC<CR>
nnoremap cfe :e ~/.vimrc<CR>
nnoremap cfs :so %<CR>

" 0 to go to the first non-blank character in the beggining of the line instead of first whitespace
map 0 ^



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" WHITESPACE SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Delete trailing whitespace on save:
autocmd BufWritePre * %s/\s\+$//e

" Show trailing spaces as dots
set list listchars=trail:·,tab:>·

" highlight trailing whitespace but prevent highlighting while in the insert mode.
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT EDITING SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Return to last edit position when opening files (You want this!)
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
" Restore last cursor position and marks on open
au BufReadPost *
      \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
      \ |   exe "normal! g`\""
      \ | endif


"" Text Wrap
if !exists('*s:setupWrapping')
  function s:setupWrapping()
    set wrap
    set wm=2
    set textwidth=79
  endfunction
endif

set showbreak=+++           " Wrap-broken line prefix
set textwidth=110                    " Line wrap (number of cols)
set linebreak                     " Break lines at word (requires Wrap lines)


" Move text with M-hjkl
nnoremap <M-j> :m .+1<CR>==
nnoremap <M-k> :m .-2<CR>==
inoremap <M-j> <Esc>:m .+1<CR>==gi
inoremap <M-k> <Esc>:m .-2<CR>==gi
vnoremap <M-j> :m '>+1<CR>gv=gv
vnoremap <M-k> :m '<-2<CR>gv=gv
"" Move visual block
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv


" replace all instances of currently selected word for new input (leader + r)
map <leader>r :%s///g<left><left>
vnoremap <C-r> "hy:%s/<C-r>h//gc<left><left><left>


" Disable Vim native text folding
" set nofoldenable

" ~    : Changes the case of current character
" guu  : Change current line from upper to lower.
" gUU  : Change current LINE from lower to upper.
" guw  : Change to end of current WORD from upper to lower.
" guaw : Change all of current WORD to lower.
" gUw  : Change to end of current WORD from lower to upper.
" gUaw : Change all of current WORD to upper.
" g~~  : Invert case to entire line
" g~w  : Invert case to current WORD
" guG : Change to lowercase until the end of document.

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SEARCH SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Makes Esc clear last search highlights after searching
nnoremap <esc> :noh<return><esc>

" Disable highlight when <leader><cr> is pressed
map <silent> <leader><cr> :noh<cr>

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :<C-u>call VisualSelection('', '')<CR>/<C-R>=@/<CR><CR>
vnoremap <silent> # :<C-u>call VisualSelection('', '')<CR>?<C-R>=@/<CR><CR>

" Search mappings: These will make it so that going to the next one in a
" search will center on the line it's found in.
nnoremap n nzzzv
nnoremap N Nzzzv

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SPELL CHECKING
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set spelllang=pt_br,en_us

" Toggle and untoggle spell checking
map <leader>ss :setlocal spell!<cr>

" Spellchecking shortcuts
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILES, BACKUPS AND UNDO
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set nobackup
set nowritebackup
set noswapfile

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TABS AND WINDOW SPLTTING
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Open new split panes to right and bottom, which feels more natural than Vim’s default:
set splitbelow
set splitright

" horizontal splits
nnoremap <silent> <leader>sh :split<CR>
nnoremap <silent> <leader>- :split<CR>

" vertical split
nnoremap <silent> <leader>sv :vsplit<CR>
nnoremap <silent> <leader>\| :vsplit<CR>

"" Switching windows with C-hjkl
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l
noremap <C-h> <C-w>h

" Switching windows with C-HJKL
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

" navigate to tabs using <leader><number>, similar to i3 workspaces switch
nnoremap <leader>1 1gt
nnoremap <leader>2 2gt
nnoremap <leader>3 3gt
nnoremap <leader>4 4gt
nnoremap <leader>5 5gt

" Useful mappings for managing tabs
map <leader>tn :tabnew<cr>
map <leader>to :tabonly<cr>
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove
map <leader>t<leader> :tabnext

" Let 'tl' toggle between this and the last accessed tab
let g:lasttab = 1
nmap <leader>tl :exe "tabn ".g:lasttab<CR>
au TabLeave * let g:lasttab = tabpagenr()

"" Opens a tab edit command with the path of the currently edited file filled
noremap <leader>te :tabe <C-R>=expand("%:p:h") . "/" <CR>


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
"" Status line


" Airline setup
let g:airline_theme='codedark'                        " this airline theme resembles VSCode blueish status bar
let g:airline_powerline_fonts = 1                     " needed by devicons
" let g:airline_theme='deus'
let g:airline#extensions#tabline#enabled = 1       " enable tabline upport
let g:airline#extensions#tabline#formatter = 'unique_tail_improved'
let g:airline#extensions#tabline#left_sep = ' '
let g:airline#extensions#tabline#left_alt_sep = '|'
let g:airline#extensions#tabline#tab_nr_type = 1   " show tab numbers
let g:airline#extensions#tabline#show_buffers = 0  " hide buffers
let g:airline#extensions#tabline#tab_min_count = 2 " hide tabline for one tab


" git branch
let g:airline#extensions#branch#enabled = 1

" ale status
let g:airline#extensions#ale#enabled = 1
let g:airline_skip_empty_sections = 1


" enable/disable coc integration >
let g:airline#extensions#coc#enabled = 1
" change error symbol: >
" let airline#extensions#coc#error_symbol = 'E:'
" change warning symbol: >
let airline#extensions#coc#warning_symbol = 'W:'
" change error format: >
let airline#extensions#coc#stl_format_err = '%E{[%e(#%fe)]}'
" change warning format: >
let airline#extensions#coc#stl_format_warn = '%W{[%w(#%fw)]}'
" let g:airline_section_error = '%{airline#util#wrap(airline#extensions#coc#get_error(),0)}'
" let g:airline_section_warning = '%{airline#util#wrap(airline#extensions#coc#get_warning(),0)}'


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TMUX & VIM STUFF

" set title of tmux window to currently open file in vim
set title
set titleold="Terminal"
set titlestring=%F

autocmd BufEnter * call system("tmux rename-window " . expand("%:t"))
autocmd VimLeave * call system("tmux setw automatic-rename")
autocmd BufEnter * let &titlestring = ' ' . expand("%:t")


"#########################################################################
"
" PLUGINS SETTINGS
"
"#########################################################################

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fzf.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" fzf on a floating window
" Required:
" - width [float range [0 ~ 1]]
" - height [float range [0 ~ 1]]
"
" Optional:
" - xoffset [float default 0.5 range [0 ~ 1]]
" - yoffset [float default 0.5 range [0 ~ 1]]
" - highlight [string default 'Comment']: Highlight group for border
" - border [string default 'rounded']: Border style
"   - 'rounded' / 'sharp' / 'horizontal' / 'vertical' / 'top' / 'bottom' / 'left' / 'right'
let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6, 'highlight': 'Todo', 'border': 'sharp' } }


map <leader>ff :Files<cr>

" Hide statusline on fzf terminal buffers for a cleaner look
if has('nvim') && !exists('g:fzf_layout')
  autocmd! FileType fzf
  autocmd  FileType fzf set laststatus=0 noshowmode noruler
    \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler
endif

" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)

" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

" Advanced customization using Vim function
inoremap <expr> <c-x><c-k> fzf#vim#complete#word({'left': '15%'})

" Replace the default dictionary completion with fzf-based fuzzy completion
inoremap <expr> <c-x><c-k> fzf#vim#complete('cat /usr/share/dict/words')


" use ripgrep if available, else try ag
if executable('rg')
  let $FZF_DEFAULT_COMMAND = 'rg --files --hidden --follow --glob "!.git/*"'
  set grepprg=rg\ --vimgrep
  command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --hidden --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
elseif executable('ag')
  let $FZF_DEFAULT_COMMAND = 'ag --hidden --ignore .git -g ""'
  set grepprg=ag\ --nogroup\ --nocolor
else
endif

cnoremap <C-P> <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <silent> <leader>fm :FZF -m<CR>

"Recovery commands from history through FZF
nmap <leader>y :History:<CR>


" Customize fzf colors to match your color scheme
" - fzf#wrap translates this to a set of `--color` options
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" COC
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
" delays and poor user experience.
set updatetime=300

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" to get the correct comment highlighting for jsonc
autocmd FileType json syntax match Comment +\/\/.\+$+

" Use <c-space> to trigger completion.
inoremap <silent><expr> <c-space> coc#refresh()


" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <Tab> and <S-Tab> to navigate the completion list:

inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"


" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
" position. Coc only does snippet and additional edit on confirm.
if has('patch8.1.1068')
  " Use `complete_info` if your (Neo)Vim version supports it.
  inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
else
  imap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
endif

" To make <cr> select the first completion item and confirm the completion when no item has been selected:
inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\<C-g>u\<CR>"


" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Use K to show documentation in preview window.
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')

" Symbol renaming.
nmap <leader>rn <Plug>(coc-rename)


" Formatting selected code.
xmap <leader>f  <Plug>(coc-format-selected)
nmap <leader>f  <Plug>(coc-format-selected)

augroup mygroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end


" Applying codeAction to the selected region.
" Example: `<leader>aap` for current paragraph
xmap <leader>a  <Plug>(coc-codeaction-selected)
nmap <leader>a  <Plug>(coc-codeaction-selected)

" Remap keys for applying codeAction to the current line.
nmap <leader>ac  <Plug>(coc-codeaction)
" Apply AutoFix to problem on the current line.
nmap <leader>qf  <Plug>(coc-fix-current)


" Introduce function text object
" NOTE: Requires 'textDocument.documentSymbol' support from the language server.
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)

" Use <TAB> for selections ranges.
" NOTE: Requires 'textDocument/selectionRange' support from the language server.
" coc-tsserver, coc-python are the examples of servers that support it.
nmap <silent> <TAB> <Plug>(coc-range-select)
xmap <silent> <TAB> <Plug>(coc-range-select)


" Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')


" Add `:Fold` command to fold current buffer.
command! -nargs=? Fold :call     CocAction('fold', <f-args>)

" Add `:OR` command for organize imports of the current buffer.
command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

" Add (Neo)Vim's native statusline support.
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline.
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}


" Mappings using CoCList:
" Show all diagnostics.
nnoremap <silent> <space>a  :<C-u>CocList diagnostics<cr>
" Manage extensions.
nnoremap <silent> <space>e  :<C-u>CocList extensions<cr>
" Show commands.
nnoremap <silent> <space>c  :<C-u>CocList commands<cr>
" Find symbol of current document.
nnoremap <silent> <space>o  :<C-u>CocList outline<cr>
" Search workspace symbols.
nnoremap <silent> <space>s  :<C-u>CocList -I symbols<cr>
" Do default action for next item.
nnoremap <silent> <space>j  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent> <space>k  :<C-u>CocPrev<CR>
" Resume latest coc list.
nnoremap <silent> <space>p  :<C-u>CocListResume<CR>


" Extensions
let g:coc_global_extensions = [
      \ 'coc-git',
      \ 'coc-highlight',
      \ 'coc-marketplace',
      \ 'coc-pairs',
      \ 'coc-html',
      \ 'coc-css',
      \ 'coc-json',
      \ 'coc-java',
      \ 'coc-rls',
      \ 'coc-tsserver',
      \ 'coc-yaml',
      \ 'coc-vimlsp',
      \ 'coc-prettier',
      \ 'coc-snippets',
      \ 'coc-project',
      \ 'coc-actions',
      \ 'coc-tsserver',
      \ 'coc-tslint-plugin',
      \ 'coc-eslint',
      \ 'coc-json',
      \ 'coc-go',
      \ ]

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" NERDTREE SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Toogle NERDTree
nnoremap <leader>fe :NERDTreeToggle<CR>
map <F8> :NERDTreeToggle<CR>


" Open NerdTree on Vim startup and move cursor to edit buffer instead of leaving it on nerdtree window w
autocmd VimEnter * NERDTree | wincmd p
autocmd VimEnter * if argc() == 1 | NERDTree | wincmd p | else | NERDTree | endif


let NERDTreeShowBookmarks=1 " Show bookmarks table on Nerdtree


" Open NerdTree directly on the file currently being edited

" Sets PWD and the tree root on the currently selected directory
let g:NERDTreeChDirMode = 2

" Make NERDTree prettier
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1

" Automatically close a tab if the only remaining window is NerdTree:
" autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Automatically delete the buffer of the file you just deleted with NerdTree:
let NERDTreeAutoDeleteBuffer = 1

" close nerd tree on opening file
let NERDTreeQuitOnOpen = 0

"" NERDTree configuration
let g:NERDTreeChDirMode=2
let g:NERDTreeIgnore=['\.rbc$', '\~$', '\.pyc$', '\.db$', '\.sqlite$', '__pycache__']
let g:NERDTreeSortOrder=['^__\.py$', '\/$', '*', '\.swp$', '\.bak$', '\~$']
let g:NERDTreeShowBookmarks=1
let g:nerdtree_tabs_focus_on_files=1
let g:NERDTreeMapOpenInTabSilent = '<RightMouse>'
let g:NERDTreeWinSize = 35



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" netrw bindings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" rmeove the useless banner
let g:netrw_banner = 0

" use tree-view (press i to alter view style)
let g:netrw_liststyle = 3

" open splits to the right
let g:netrw_altv = 1

" If you’ve set custom wildignores netrw can inherit them by doing this:
let g:netrw_list_hide = &wildignore

" " Open netrw on vim enter
" augroup ProjectDrawer
"   autocmd!
"   autocmd VimEnter * :Vexplore
" augroup END

" Change how files are opened
" 1 - open files in a new horizontal split
" 2 - open files in a new vertical split
" 3 - open files in a new tab
" 4 - open in previous window
let g:netrw_browse_split = 4

" Netrw width
let g:netrw_winsize = 25 " that means 25% of the current view (page / window)


" Mapping q to close netrw is easily solved:
autocmd FileType netrw nnoremap q :bd<CR>
" (Or if you want the split it's in to stay open:)
autocmd FileType netrw nnoremap q :bp\|bd #<CR>


let g:NetrwIsOpen=0

function! ToggleNetrw()
    if g:NetrwIsOpen
        let i = bufnr("$")
        while (i >= 1)
            if (getbufvar(i, "&filetype") == "netrw")
                silent exe "bwipeout " . i
            endif
            let i-=1
        endwhile
        let g:NetrwIsOpen=0
    else
        let g:NetrwIsOpen=1
        silent Lexplore
    endif
endfunction

" Add your own mapping. For example:
noremap <silent> <F4> :call ToggleNetrw()<CR>


" supposed improved version of the above toggle netrw function
" try it out
" Based on alwc's answer without using global state. This way it doesn't get out of sync when Netrw was open manually first. It will still "glitch" when opening Netrw manully after it was opend with this function. But there is nothing one can do about manual commands I guess.

function! ToggleNetrw2()
        let i = bufnr("$")
        let wasOpen = 0
        while (i >= 1)
            if (getbufvar(i, "&filetype") == "netrw")
                silent exe "bwipeout " . i
                let wasOpen = 1
            endif
            let i-=1
        endwhile
    if !wasOpen
        silent Lexplore
    endif
endfunction
map <F3> :call ToggleNetrw2() <CR>

" open in current window
" map <F3> :Explore<CR>
" vertical split
" map <F4> :Vexplore<CR>
" map <S-F4> :Vexplore<CR>
" horizontal split
map <F5> :Sexplore<CR>



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Ale
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" show linting errors on a separate window
" let g:ale_open_list = 1
" let g:ale_list_window_size = 5
"
let g:ale_sign_error = '>>'
let g:ale_sign_warning = '--'

" Show X lines of errors (default: 10)
let g:ale_list_window_size = 10

" ale
let g:ale_linters = {}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Expand Region
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Press + to expand the visual selection and _ to shrink it.

" Customize the key mapping if you don't like the default.
" map K <Plug>(expand_region_expand)
" map J <Plug>(expand_region_shrink)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TsLint
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" auto lint when saving typescript files
" autocmd BufWritePost *.ts,*.tsx call tslint#run('a', win_getid())


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" blamer - gitlens implementation for vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:blamer_enabled = 0

let g:blamer_delay = 500
let g:blamer_show_in_visual_modes = 0
let g:blamer_prefix = ' > '

" Template for the blame message
" Available options: <author>, <author-mail>, <author-time>, <committer>, <committer-mail>, <committer-time>, <summary>, <commit-short>, <commit-long>.
let g:blamer_template = '<committer>, <committer-time> • <summary>'

" The color of the blame message.
" highlight Blamer guifg=lightgrey


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" nvim blame line - another gitlens like implementation
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

nnoremap <silent> <leader>gb :ToggleBlameLine<CR>

" Use autocmd to enable on startup:
" autocmd BufEnter * EnableBlameLine

" Options
" Show blame info below the statusline instead of using virtual text
let g:blameLineUseVirtualText = 0

" Specify the highlight group used for the virtual text ('Comment' by default)
let g:blameLineVirtualTextHighlight = 'Question'

" Add a prefix to the virtual text (empty by default)
let g:blameLineVirtualTextPrefix = '// '

" Customize format for git blame (Default format: '%an | %ar | %s')
let g:blameLineGitFormat = '%an - %s'
" Refer to 'git-show --format=' man pages for format options)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EMMET SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Use TAB to expand emmet snippets (equivalent to <C-y>,
" let g:user_emmet_expandabbr_key = '<S-tab>'
" Create another binding for emmet, because the default is not great
" map <C-Space> <c-y>,

" navigate to edit points
inoremap <C->> <c-y>n<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Prettier
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:prettier#config#print_width = 100
let g:prettier#autoformat = 0
let g:prettier#config#tab_width = 4

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Matchup
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Customizing the highlighting colors
:highlight MatchParen ctermbg=blue guibg=lightblue cterm=italic gui=italic

" You may want to put this inside a ColorScheme autocmd so it is preserved after colorscheme changes:
augroup matchup_matchparen_highlight
  autocmd!
  autocmd ColorScheme * highlight MatchParen guifg=red
augroup END

" You can also highlight words differently than parentheses using the MatchWord highlighting group. You might do this if you find the MatchParen style distracting for large blocks.
:highlight MatchWord ctermfg=red guifg=blue cterm=underline gui=underline

" There are also MatchParenCur and MatchWordCur which allow you to configure the highlight separately for the match under the cursor.
:highlight MatchParenCur cterm=underline gui=underline
:highlight MatchWordCur cterm=underline gui=underline

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Rainbow Parentheses Improved
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:rainbow_active = 1
" let g:rainbow_conf = {'guifgs': ['#FFD700','#C466C0','#7AB9E0']}
let g:rainbow_conf = {'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick']}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" VIM COLORIZER SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Make colorizer start when opening or creating files
:autocmd BufNewFile,BufRead * ColorHighlight


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" VIM ILLUMINATE SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" disable illuminate words on NerdTREE
let g:Illuminate_ftblacklist = ['nerdtree']


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" VIM DEVICONS SETTINGS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:webdevicons_enable = 1
let g:webdevicons_enable_nerdtree = 1 " adding the flags to NERDTree
let g:webdevicons_enable_airline_tabline = 1 " adding to vim-airline's tabline
let g:webdevicons_enable_airline_statusline = 1 " adding to vim-airline's statusline
let g:webdevicons_conceal_nerdtree_brackets = 1 " whether or not to show the nerdtree brackets around flags
let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1 " Force extra padding in NERDTree so that the filetype icons line up vertically
let g:webdevicons_enable_denite = 1 " Adding the custom source to denite

" solve the issue with NERDTree devicons bugging after sourcing vimrc
if exists("g:loaded_webdevicons")
  call webdevicons#refresh()
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" HELPER METHODS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" align() function  similar to emacs align-regexp
"source: https://vim.fandom.com/wiki/Regex-based_text_alignment
function! AlignSection(regex) range
  let extra = 1
  let sep = empty(a:regex) ? '=' : a:regex
  let maxpos = 0
  let section = getline(a:firstline, a:lastline)
  for line in section
    let pos = match(line, ' *'.sep)
    if maxpos < pos
      let maxpos = pos
    endif
  endfor
  call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
  call setline(a:firstline, section)
endfunction

function! AlignLine(line, sep, maxpos, extra)
  let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
  if empty(m)
    return a:line
  endif
  let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
  return m[1] . spaces . m[2]
endfunction

command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')

"--------------------------------------------

function! VisualSelection(direction, extra_filter) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'b'
    execute "normal ?" . l:pattern . "^M"
  elseif a:direction == 'gv'
    call CmdLine("Ack \"" . l:pattern . "\" " )
  elseif a:direction == 'replace'
    call CmdLine("%s" . '/'. l:pattern . '/')
  elseif a:direction == 'f'
    execute "normal /" . l:pattern . "^M"
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

"--------------------------------------------

" Returns true if paste mode is enabled (used by statusline)
function! HasPaste()
  if &paste
    return 'PASTE MODE  '
  endif
  return ''
endfunction

"--------------------------------------------

" Zoom / Restore window.
function! s:ZoomToggle() abort
  if exists('t:zoomed') && t:zoomed
    execute t:zoom_winrestcmd
    let t:zoomed = 0
  else
    let t:zoom_winrestcmd = winrestcmd()
    resize
    vertical resize
    let t:zoomed = 1
  endif
endfunction
command! ZoomToggle call s:ZoomToggle()

" mapping the ZoomToggle function
noremap <leader>z :ZoomToggle<CR>



" review all these bellow (from vim-boostrap for neovim)


"*****************************************************************************
"" Abbreviations
"*****************************************************************************
"" no one is really happy until you have this shortcuts
cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qall! qall!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qall qall


" grep.vim
nnoremap <silent> <leader>fg :Rgrep<CR>
let Grep_Default_Options = '-IR'
let Grep_Skip_Files = '*.log *.db'
let Grep_Skip_Dirs = '.git node_modules'



"*****************************************************************************
"" Mappings
"*****************************************************************************

" Fast saving
nmap <leader>w :w!<cr>

" Fast quitting
nmap <leader>q :q!<cr>

" :W sudo saves the file
command! W w !sudo tee % > /dev/null


"" Quick exit insert mode with jk
inoremap jk <ESC>

" Easy Align plugin
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

vnoremap <silent> <Leader>al :Align<CR>

"" Split
noremap <Leader>h :<C-u>split<CR>
noremap <Leader>v :<C-u>vsplit<CR>

"" Git
noremap <Leader>ga :Gwrite<CR>
noremap <Leader>gc :Gcommit<CR>
noremap <Leader>gsh :Gpush<CR>
noremap <Leader>gll :Gpull<CR>
noremap <Leader>gs :Gstatus<CR>
noremap <Leader>gb :Gblame<CR>
noremap <Leader>gd :Gvdiff<CR>
noremap <Leader>gr :Gremove<CR>


"" Vmap for maintain Visual Mode after shifting > and <
vmap < <gv
vmap > >gv

"" Open current line on GitHub
nnoremap <Leader>o :.Gbrowse<CR>

"#########################################################################
"
" LANGUAGES SETTINGS
"
"#########################################################################


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" html
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" for html files, 2 spaces
autocmd Filetype html setlocal ts=2 sw=2 expandtab

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" javascript
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:javascript_enable_domhtmlcss = 1

" vim-javascript
augroup vimrc-javascript
  autocmd!
  autocmd FileType javascript setl tabstop=4|setl shiftwidth=4|setl expandtab softtabstop=4
augroup END

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" typescript
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" typescript
let g:yats_host_keyword = 1



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" elixir
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" erlang
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let erlang_folding = 1
let erlang_show_errors = 1


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" go
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" organize imports on save
autocmd BufWritePre *.go :call CocAction('runCommand', 'editor.action.organizeImport')


" add go vet to ale linters
:call extend(g:ale_linters, {
      \"go": ['golint', 'go vet'], })

" vim-go
" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand('%')
  if l:file =~# '^\f\+_test\.go$'
    call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

let g:go_list_type = "quickfix"
let g:go_fmt_command = "goimports"
let g:go_fmt_fail_silently = 1

let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_structs = 1
let g:go_highlight_generate_tags = 1
let g:go_highlight_space_tab_error = 0
let g:go_highlight_array_whitespace_error = 0
let g:go_highlight_trailing_whitespace_error = 0
let g:go_highlight_extra_types = 1

autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4 softtabstop=4

augroup completion_preview_close
  autocmd!
  if v:version > 703 || v:version == 703 && has('patch598')
    autocmd CompleteDone * if !&previewwindow && &completeopt =~ 'preview' | silent! pclose | endif
  endif
augroup END

augroup go

  au!
  au Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
  au Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
  au Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
  au Filetype go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')

  au FileType go nmap <Leader>dd <Plug>(go-def-vertical)
  au FileType go nmap <Leader>dv <Plug>(go-doc-vertical)
  au FileType go nmap <Leader>db <Plug>(go-doc-browser)

  au FileType go nmap <leader>r  <Plug>(go-run)
  au FileType go nmap <leader>t  <Plug>(go-test)
  au FileType go nmap <Leader>gt <Plug>(go-coverage-toggle)
  au FileType go nmap <Leader>i <Plug>(go-info)
  au FileType go nmap <silent> <Leader>l <Plug>(go-metalinter)
  au FileType go nmap <C-g> :GoDecls<cr>
  au FileType go nmap <leader>dr :GoDeclsDir<cr>
  au FileType go imap <C-g> <esc>:<C-u>GoDecls<cr>
  au FileType go imap <leader>dr <esc>:<C-u>GoDeclsDir<cr>
  au FileType go nmap <leader>rb :<C-u>call <SID>build_go_files()<CR>

augroup END


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" haskell
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:haskell_conceal_wide = 1
let g:haskell_multiline_strings = 1
let g:necoghc_enable_detailed_browse = 1
autocmd Filetype haskell setlocal omnifunc=necoghc#omnifunc


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ruby
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_rails = 1

augroup vimrc-ruby
  autocmd!
  autocmd BufNewFile,BufRead *.rb,*.rbw,*.gemspec setlocal filetype=ruby
  autocmd FileType ruby set tabstop=2|set shiftwidth=2|set expandtab softtabstop=2
augroup END

let g:tagbar_type_ruby = {
      \ 'kinds' : [
      \ 'm:modules',
      \ 'c:classes',
      \ 'd:describes',
      \ 'C:contexts',
      \ 'f:methods',
      \ 'F:singleton methods'
      \ ]
      \ }

" RSpec.vim mappings
map <Leader>t :call RunCurrentSpecFile()<CR>
map <Leader>s :call RunNearestSpec()<CR>
map <Leader>l :call RunLastSpec()<CR>
map <Leader>a :call RunAllSpecs()<CR>

" For ruby refactory
if has('nvim')
  runtime! macros/matchit.vim
else
  packadd! matchit
endif

" Ruby refactory
nnoremap <leader>rap  :RAddParameter<cr>
nnoremap <leader>rcpc :RConvertPostConditional<cr>
nnoremap <leader>rel  :RExtractLet<cr>
vnoremap <leader>rec  :RExtractConstant<cr>
vnoremap <leader>relv :RExtractLocalVariable<cr>
nnoremap <leader>rit  :RInlineTemp<cr>
vnoremap <leader>rrlv :RRenameLocalVariable<cr>
vnoremap <leader>rriv :RRenameInstanceVariable<cr>
vnoremap <leader>rem  :RExtractMethod<cr>


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" rust
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Vim racer
au FileType rust nmap gd <Plug>(rust-def)
au FileType rust nmap gs <Plug>(rust-def-split)
au FileType rust nmap gx <Plug>(rust-def-vertical)
au FileType rust nmap <leader>gd <Plug>(rust-doc)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" markdown
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Disable folding on Vim Markdown
let g:vim_markdown_folding_disabled = 1


